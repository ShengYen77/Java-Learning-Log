# ⭐多執行緒(Multithreading)

是指：在一個程式中同時執行多個工作(執行緒Thread)。

能夠提高效能，適合下載、檔案處理、網路連線等需要同時處理多件事的情境。

在多執行緒當中有兩種基本做法 :

Thread : 建立一個子類別繼承 Thread 並覆寫 run() 方法。

Runnable : 建立一個類別實作 Runnable，然後傳入 Thread 物件中運作。

# Thread範例程式碼
```
class MyThread extends Thread {           //宣告一個類別 MyThread，繼承自 Thread 類別，代表它是一個可以執行的執行緒。
    public void run() {                   //覆寫 Thread 類別中的 run() 方法，當執行緒啟動時，這段程式會被執行。
        for (int i = 1; i <= 5; i++) {                        //用迴圈重複執行 5 次。
            System.out.println("執行緒 A：第 " + i + " 次");   //輸出當前迴圈次數，模擬執行緒 A 的執行狀態。
        }
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();                      //建立 MyThread 類別的實體 t1，準備建立一個執行緒物件。
        t1.start();                                        //啟動執行緒 t1，會自動執行 run() 方法內容（不是呼叫 run()）。
        
        for (int i = 1; i <= 5; i++) {                     //主程式也跑一個迴圈執行 5 次。
            System.out.println("主程式：第 " + i + " 次");  //輸出主程式執行的次數。
        }
    }
}
```
執行結果不一定是主程式與執行緒 A 交替印出，有時可能某一方先印完(因為執行緒調度由 JVM 和作業系統決定)。

# Runnable範例程式碼
```
class MyRunnable implements Runnable {                      //定義類別 MyRunnable，實作 Runnable 介面，使其可以被用於執行緒中。
    public void run() {                                     //實作介面的 run() 方法，執行緒啟動時執行的程式碼邏輯。
        for (int i = 1; i <= 5; i++) {                      //建立一個 for 迴圈，從 1 執行到 5。
            System.out.println("執行緒 B：第 " + i + " 次"); //印出目前執行緒的次數。
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Thread t2 = new Thread(new MyRunnable());            //建立 MyRunnable 類別的物件實例。
        t2.start();                                          //啟動執行緒，會呼叫 run() 方法內容。
        
        for (int i = 1; i <= 5; i++) {                       //主程式也會跑一個 for 迴圈 5 次。
            System.out.println("主程式：第 " + i + " 次");    //印出主程式目前執行的次數。
        }
    }
}
```
| 對比項目            | Thread 繼承寫法（範例一）  | Runnable 實作寫法（範例二）|
|--------------------|--------------------------|----------------------|
| 類別宣告方式       | class A extends Thread    | class B implements Runnable |
| 執行緒建立         | A a = new A(); a.start(); | Runnable r = new B(); new Thread(r).start();|
| 優點              | 簡單直接                   | 可繼承其他類別，更彈性    |


# 執行緒生命週期階段
| 狀態 (State)     | 說明                        |
|--------------------|--------------------------|
| New (新建)            | 執行緒物件已建立，尚未啟動（呼叫 .start() 前）。    |
| Runnable（可執行）     | 呼叫 .start() 後，等待 CPU 排程執行。     |
| Running（執行中）      | CPU 正在執行該執行緒（實際上是從 Runnable 中選中執行）。    |
| Blocked（阻塞）         | 嘗試存取被其他執行緒鎖定的資源，需等待釋放鎖（例如 synchronized 區塊）。    |
| Waiting（等待）         | 執行緒等待其他執行緒明確喚醒它（如 wait() 搭配 notify()）。    |
| Timed Waiting（定時等待）| 等待一定時間後自動醒來（如 sleep()、join(timeout)）。    |
| Terminated（終止）         | 執行完成或發生例外而結束。   |


+---------+

  New       ← 建立 Thread 物件

+----+----+

     ↓
     
     ↓ .start()
     
     ↓
     
+----+----+

 Runnable   ← 準備就緒，等 CPU 執行

+----+----+

     ↓
     
     ↓ 執行中
     
     ↓
     
+---------+

 Running 

+----+----+

     ↓         ↘           ↘
     
     ↓            ↘            ↘
     
     ↓  sleep()  wait()  synchronized block
     
     ↓              ↓         ↓
     
+-------------+ +--------+ +--------+

 |TimedWait  |   |  Waiting | |  Blocked |

+-------------+ +--------+ +--------+

     ↘              ↓          ↓
     
      ↘          notify()    取得鎖
      
       ↘            ↓          ↓
       
        +------> Runnable <------+
        
                   ↓
                   
                   ↓ run 結束或例外
                   
                   ↓
                   
               +--------+
               
               Terminated
               
               +--------+
               


